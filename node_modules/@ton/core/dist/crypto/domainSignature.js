"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.domainSignVerify = exports.domainSign = exports.domainDataToSign = exports.signatureDomainPrefix = exports.signatureDomainHash = void 0;
const crypto_1 = require("@ton/crypto");
const SignatureDomain_1 = require("../types/SignatureDomain");
function signatureDomainHash(domain) {
    switch (domain.type) {
        case "empty":
            const tl = Buffer.alloc(4);
            tl.writeInt32LE(SignatureDomain_1.signatureDomainEmptyTag);
            return (0, crypto_1.sha256_sync)(tl);
        case "l2": {
            const tl = Buffer.alloc(8);
            tl.writeInt32LE(SignatureDomain_1.signatureDomainL2Tag);
            tl.writeInt32LE(domain.globalId, 4);
            return (0, crypto_1.sha256_sync)(tl);
        }
        default:
            throw new Error(`Unknown SignatureDomain type ${domain.type}`);
    }
}
exports.signatureDomainHash = signatureDomainHash;
const signatureDomainEmptyHash = signatureDomainHash({ type: "empty" });
function signatureDomainPrefix(domainOrHash) {
    const domainHash = Buffer.isBuffer(domainOrHash)
        ? domainOrHash
        : signatureDomainHash(domainOrHash);
    if (domainHash.length !== 32) {
        throw new Error("Invalid signature domain hash length");
    }
    if (domainHash.equals(signatureDomainEmptyHash)) {
        return null;
    }
    return domainHash;
}
exports.signatureDomainPrefix = signatureDomainPrefix;
function domainDataToSign(data, domain) {
    const prefix = signatureDomainPrefix(domain);
    return prefix ? Buffer.concat([prefix, data]) : data;
}
exports.domainDataToSign = domainDataToSign;
function domainSign({ data, secretKey, domain = { type: "empty" }, }) {
    const dataToSign = domainDataToSign(data, domain);
    return (0, crypto_1.sign)(dataToSign, secretKey);
}
exports.domainSign = domainSign;
function domainSignVerify({ data, signature, publicKey, domain = { type: "empty" }, }) {
    const dataToSign = domainDataToSign(data, domain);
    return (0, crypto_1.signVerify)(dataToSign, signature, publicKey);
}
exports.domainSignVerify = domainSignVerify;
